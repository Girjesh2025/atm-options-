//@version=5
// ══════════════════════════════════════════════════════════════════════════════
// ATM Option Strike Selector Indicator v2.0
// For TradingView Pine Script v5
// Improved version with multiple features and enhanced UI
// For educational purposes only
// ══════════════════════════════════════════════════════════════════════════════

indicator("ATM Option Strike Selector v2.0", shorttitle="ATM Options", overlay=true)

// ═══════════════════════════ INPUTS ═══════════════════════════

// ——— Strategy Settings Tab ———
var strategyTab = "Strategy Settings"
ma_type = input.string("SMA", "Moving Average Type", options=["SMA", "EMA", "VWAP", "Hull"], group=strategyTab)
ma_length = input.int(20, "Moving Average Length", minval=1, group=strategyTab)
atr_length = input.int(14, "ATR Period", minval=1, group=strategyTab)
atr_smooth = input.int(1, "ATR Smoothing", minval=1, maxval=10, group=strategyTab)
use_crossover = input.bool(false, "Use MA Crossover", tooltip="When enabled, uses crossover of two MAs instead of price/MA relationship", group=strategyTab)
fast_ma_length = input.int(9, "Fast MA Length", minval=1, group=strategyTab, tooltip="Only used if crossover is enabled")

// ——— Risk Management Tab ———
var riskTab = "Risk Management"
atr_multiplier_sl = input.float(1.0, "ATR Multiplier for SL", minval=0.1, step=0.1, group=riskTab)
target1_multiplier = input.float(1.5, "Target 1 (Risk:Reward)", minval=0.1, step=0.1, group=riskTab)
target2_multiplier = input.float(2.5, "Target 2 (Risk:Reward)", minval=0.1, step=0.1, group=riskTab)
target3_multiplier = input.float(3.5, "Target 3 (Risk:Reward)", minval=0.1, step=0.1, group=riskTab)
use_percentage = input.bool(false, "Use Percentage for Risk", tooltip="Calculate SL and targets as % of price rather than ATR", group=riskTab)
percentage_risk = input.float(1.0, "SL Percentage", minval=0.1, step=0.1, group=riskTab, tooltip="Only used if percentage risk is enabled")

// ——— Option Settings Tab ———
var optionsTab = "Option Settings"
strike_interval = input.int(50, "Strike Price Interval", tooltip="Standard interval between option strikes", group=optionsTab)
round_base = input.int(50, "Round Base for Strikes", tooltip="Round ATM strike to nearest value divisible by this", group=optionsTab)
advanced_options = input.bool(false, "Show Additional Option Strikes", group=optionsTab)
otm_count = input.int(2, "OTM Strike Count", minval=0, maxval=5, group=optionsTab, tooltip="Number of OTM strikes to display")
itm_count = input.int(1, "ITM Strike Count", minval=0, maxval=5, group=optionsTab, tooltip="Number of ITM strikes to display")

// ——— Display Settings Tab ———
var displayTab = "Display Settings"
show_signals = input.bool(true, "Show Entry Signals", group=displayTab)
signal_lookback = input.int(3, "Signal Lookback Bars", minval=1, maxval=50, group=displayTab, tooltip="How many bars to show signals for")
show_sl_targets = input.bool(true, "Show SL & Targets", group=displayTab)
show_ma = input.bool(true, "Show Moving Average", group=displayTab)
show_panel = input.bool(true, "Show Info Panel", group=displayTab)
panel_position = input.string("Right", "Panel Position", options=["Left", "Right"], group=displayTab)
panel_size = input.string("Normal", "Panel Size", options=["Small", "Normal", "Large"], group=displayTab)

// ═══════════════════════════ FUNCTIONS ═══════════════════════════

// Function to calculate different types of moving averages
getMA(source, length, type) =>
    switch type
        "SMA" => ta.sma(source, length)
        "EMA" => ta.ema(source, length)
        "VWAP" => ta.vwap(source)
        "Hull" => ta.wma(2 * ta.wma(source, length / 2) - ta.wma(source, length), math.round(math.sqrt(length)))
        => ta.sma(source, length) // default

// Function to round to nearest strike
roundToNearestStrike(price, base) =>
    math.round(price / base) * base

// Function to format price values nicely
formatPrice(price) =>
    str.tostring(math.round_to_mintick(price))

// ═══════════════════════════ CALCULATIONS ═══════════════════════════

// Calculate the moving averages
main_ma = getMA(close, ma_length, ma_type)
fast_ma = getMA(close, fast_ma_length, ma_type)

// Calculate ATR for stop loss and targets
atr_value = ta.ema(ta.atr(atr_length), atr_smooth)

// Calculate trend direction based on selected method
uptrend = use_crossover ? fast_ma > main_ma and fast_ma[1] <= main_ma[1] : close > main_ma and close[1] > main_ma[1] and main_ma > main_ma[1]

downtrend = use_crossover ? fast_ma < main_ma and fast_ma[1] >= main_ma[1] : close < main_ma and close[1] < main_ma[1] and main_ma < main_ma[1]

// Get the nearest strikes
atm_strike = roundToNearestStrike(close, round_base)

// Calculate option strikes (ATM, ITM, OTM)
var strikes = array.new_float()
array.clear(strikes)

// ATM strike is always included
array.push(strikes, atm_strike)

// Add ITM strikes
if itm_count > 0
    for i = 1 to itm_count
        if uptrend
            array.push(strikes, atm_strike - (i * strike_interval))
        else if downtrend
            array.push(strikes, atm_strike + (i * strike_interval))

// Add OTM strikes
if otm_count > 0
    for i = 1 to otm_count
        if uptrend
            array.push(strikes, atm_strike + (i * strike_interval))
        else if downtrend
            array.push(strikes, atm_strike - (i * strike_interval))

// Determine Option Type
option_type = uptrend ? "CE" : downtrend ? "PE" : "NA"

// Calculate risk parameters
risk_distance = use_percentage ? 
    close * percentage_risk / 100 : 
    atr_value * atr_multiplier_sl

// Calculate Stop Loss and Targets
sl_level = uptrend ? close - risk_distance : downtrend ? close + risk_distance : na
target1_level = uptrend ? close + (risk_distance * target1_multiplier) : downtrend ? close - (risk_distance * target1_multiplier) : na
target2_level = uptrend ? close + (risk_distance * target2_multiplier) : downtrend ? close - (risk_distance * target2_multiplier) : na
target3_level = uptrend ? close + (risk_distance * target3_multiplier) : downtrend ? close - (risk_distance * target3_multiplier) : na

// Entry signal with persistence
var int signal_count = 0
var string current_signal = "none"

if uptrend and not uptrend[1]
    signal_count := signal_lookback
    current_signal := "buy"
else if downtrend and not downtrend[1]
    signal_count := signal_lookback
    current_signal := "sell"
else if signal_count > 0
    signal_count -= 1
    if signal_count == 0
        current_signal := "none"

// ═══════════════════════════ PLOTTING ═══════════════════════════

// Plot the moving average
if show_ma
    ma_color = uptrend ? color.green : downtrend ? color.red : color.gray
    ma_line = plot(main_ma, "Moving Average", color=ma_color, linewidth=2)
    
    if use_crossover
        fast_plot = plot(fast_ma, "Fast MA", color=color.new(color.blue, 40), linewidth=1)
        fill(ma_line, fast_plot, color=fast_ma > main_ma ? color.new(color.green, 90) : color.new(color.red, 90))

// Background coloring for trend
bgcolor(uptrend ? color.new(color.green, 95) : downtrend ? color.new(color.red, 95) : na)

// Plot entry signals
if show_signals and signal_count > 0
    plotshape(current_signal == "buy", "Buy Signal", style=shape.labelup, location=location.belowbar, 
              color=color.green, size=size.small, text="BUY")
    plotshape(current_signal == "sell", "Sell Signal", style=shape.labeldown, location=location.abovebar, 
              color=color.red, size=size.small, text="SELL")

// Plot Stop Loss and Target lines if there's a trend and they should be shown
if show_sl_targets and (uptrend or downtrend)
    plot(sl_level, "Stop Loss", color=color.new(color.red, 0), style=plot.style_linebr, linewidth=2)
    plot(target1_level, "Target 1", color=color.new(color.green, 20), style=plot.style_linebr, linewidth=1)
    plot(target2_level, "Target 2", color=color.new(color.green, 10), style=plot.style_linebr, linewidth=1)
    plot(target3_level, "Target 3", color=color.new(color.green, 0), style=plot.style_linebr, linewidth=1)

// ═══════════════════════════ INFO PANEL ═══════════════════════════

// Create info panel
if show_panel
    var label info_panel = na
    var table info_table = na

    // Set panel text size based on user preference
    var textSize = panel_size == "Small" ? size.small : panel_size == "Large" ? size.large : size.normal

    if uptrend or downtrend
        // Delete previous label if it exists
        if not na(info_panel)
            label.delete(info_panel)
            
        if not na(info_table)
            table.delete(info_table)
            
        // Position settings
        var table_position = panel_position == "Left" ? position.top_left : position.top_right
        
        // Create new table-based panel
        info_table := table.new(table_position, columns=2, rows=advanced_options ? 6 + array.size(strikes) : 6, 
                              bgcolor=color.new(uptrend ? color.green : color.red, 80), 
                              border_width=1)
        
        // Build header
        table.cell(info_table, 0, 0, "ATM OPTION STRATEGY", bgcolor=color.new(uptrend ? color.green : color.red, 60), 
                   text_color=color.white, text_size=textSize)
        table.cell(info_table, 1, 0, uptrend ? "BULLISH" : "BEARISH", bgcolor=color.new(uptrend ? color.green : color.red, 60), 
                   text_color=color.white, text_size=textSize)
        
        // Add strike information
        table.cell(info_table, 0, 1, "ATM Strike:", text_color=color.white, text_size=textSize)
        table.cell(info_table, 1, 1, str.tostring(atm_strike) + " " + option_type, text_color=color.white, text_size=textSize)
        
        // Add risk management information
        table.cell(info_table, 0, 2, "Entry:", text_color=color.white, text_size=textSize)
        table.cell(info_table, 1, 2, formatPrice(close), text_color=color.white, text_size=textSize)
        
        table.cell(info_table, 0, 3, "Stop Loss:", text_color=color.red, text_size=textSize)
        table.cell(info_table, 1, 3, formatPrice(sl_level), text_color=color.red, text_size=textSize)
        
        table.cell(info_table, 0, 4, "Targets:", text_color=color.green, text_size=textSize)
        target_text = "T1: " + formatPrice(target1_level) + "\nT2: " + formatPrice(target2_level) + "\nT3: " + formatPrice(target3_level)
        table.cell(info_table, 1, 4, target_text, text_color=color.green, text_size=textSize)
        
        // Calculate Risk:Reward
        rr_text = "1:" + str.tostring(target1_multiplier) + " / 1:" + str.tostring(target2_multiplier) + " / 1:" + str.tostring(target3_multiplier)
        table.cell(info_table, 0, 5, "Risk:Reward:", text_color=color.white, text_size=textSize)
        table.cell(info_table, 1, 5, rr_text, text_color=color.white, text_size=textSize)
        
        // Add additional strikes if advanced options are enabled
        if advanced_options and array.size(strikes) > 1
            table.cell(info_table, 0, 6, "Option Strikes:", text_color=color.white, text_size=textSize, bgcolor=color.new(color.gray, 70))
            table.cell(info_table, 1, 6, option_type, text_color=color.white, text_size=textSize, bgcolor=color.new(color.gray, 70))
            
            for i = 0 to array.size(strikes) - 1
                strike_value = array.get(strikes, i)
                is_atm = strike_value == atm_strike
                
                strike_bg = is_atm ? color.new(color.blue, 70) : color.new(color.gray, 90)
                strike_text = is_atm ? "ATM: " + str.tostring(strike_value) : str.tostring(strike_value)
                
                table.cell(info_table, 0, 7 + i, strike_text, text_color=color.white, text_size=textSize, bgcolor=strike_bg)
                
                // Calculate option price (simplified)
                distance_from_spot = math.abs(strike_value - close)
                intrinsic = math.max(0, uptrend ? close - strike_value : strike_value - close)
                time_value = distance_from_spot * 0.1  // Very simplified option pricing
                
                option_price_text = "~" + str.tostring(math.round_to_mintick(intrinsic + time_value))
                table.cell(info_table, 1, 7 + i, option_price_text, text_color=color.white, text_size=textSize, bgcolor=strike_bg)

// ═══════════════════════════ ALERTS ═══════════════════════════

// Add alerts
alertcondition(uptrend and not uptrend[1], "Buy Signal", "Buy signal detected - {{ticker}} at {{close}}")
alertcondition(downtrend and not downtrend[1], "Sell Signal", "Sell signal detected - {{ticker}} at {{close}}")
alertcondition(close >= target1_level and close[1] < target1_level, "Target 1 Hit", "Target 1 reached for {{ticker}}")
alertcondition(close >= target2_level and close[1] < target2_level, "Target 2 Hit", "Target 2 reached for {{ticker}}")
alertcondition(close >= target3_level and close[1] < target3_level, "Target 3 Hit", "Target 3 reached for {{ticker}}")
alertcondition(close <= sl_level and close[1] > sl_level, "Stop Loss Hit", "Stop loss triggered for {{ticker}}")
